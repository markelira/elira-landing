#!/usr/bin/env npx ts-node

/**
 * ELIRA Firebase Key Rotation Script
 * 
 * This script helps rotate Firebase API keys and service account credentials
 * following security best practices outlined in the production roadmap.
 * 
 * Usage: npx ts-node scripts/rotate-keys.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import * as readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function askQuestion(question: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer);
    });
  });
}

interface FirebaseConfig {
  FIREBASE_API_KEY: string;
  FIREBASE_AUTH_DOMAIN: string;
  FIREBASE_PROJECT_ID: string;
  FIREBASE_STORAGE_BUCKET: string;
  FIREBASE_MESSAGING_SENDER_ID: string;
  FIREBASE_APP_ID: string;
  FIREBASE_MEASUREMENT_ID?: string;
}

interface EnvBackup {
  timestamp: string;
  config: FirebaseConfig;
  filename: string;
}

class FirebaseKeyRotator {
  private envLocalPath = '.env.local';
  private functionsEnvPath = 'functions/.env';
  private secureBackupsPath = '../secure/backups';
  private currentConfig: FirebaseConfig | null = null;

  constructor() {
    console.log('üîê ELIRA Firebase Key Rotation Tool');
    console.log('=' .repeat(50));
  }

  /**
   * Create secure backup of current configuration
   */
  private createSecureBackup(): void {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    // Ensure secure backups directory exists
    if (!fs.existsSync(this.secureBackupsPath)) {
      fs.mkdirSync(this.secureBackupsPath, { recursive: true });
    }

    // Backup current env files if they exist
    if (fs.existsSync(this.envLocalPath)) {
      const backupPath = path.join(this.secureBackupsPath, `env.local.${timestamp}.backup`);
      fs.copyFileSync(this.envLocalPath, backupPath);
      console.log(`üìÅ Backed up .env.local to: ${backupPath}`);
    }

    if (fs.existsSync(this.functionsEnvPath)) {
      const backupPath = path.join(this.secureBackupsPath, `functions.env.${timestamp}.backup`);
      fs.copyFileSync(this.functionsEnvPath, backupPath);
      console.log(`üìÅ Backed up functions/.env to: ${backupPath}`);
    }
  }

  /**
   * Read current Firebase configuration
   */
  private readCurrentConfig(): FirebaseConfig | null {
    if (!fs.existsSync(this.envLocalPath)) {
      console.log('‚ö†Ô∏è  No existing .env.local found');
      return null;
    }

    const envContent = fs.readFileSync(this.envLocalPath, 'utf8');
    const config: Partial<FirebaseConfig> = {};

    // Parse existing environment variables
    const lines = envContent.split('\n');
    for (const line of lines) {
      const match = line.match(/^NEXT_PUBLIC_FIREBASE_(\w+)="(.+)"$/);
      if (match) {
        const [, key, value] = match;
        config[`FIREBASE_${key}` as keyof FirebaseConfig] = value;
      }
    }

    return Object.keys(config).length > 0 ? config as FirebaseConfig : null;
  }

  /**
   * Validate Firebase configuration
   */
  private validateConfig(config: FirebaseConfig): boolean {
    const requiredFields: (keyof FirebaseConfig)[] = [
      'FIREBASE_API_KEY',
      'FIREBASE_AUTH_DOMAIN', 
      'FIREBASE_PROJECT_ID',
      'FIREBASE_STORAGE_BUCKET',
      'FIREBASE_MESSAGING_SENDER_ID',
      'FIREBASE_APP_ID'
    ];

    for (const field of requiredFields) {
      if (!config[field] || config[field].includes('your-') || config[field].includes('new-')) {
        console.log(`‚ùå Invalid or placeholder value for ${field}: ${config[field]}`);
        return false;
      }
    }

    // Validate format patterns
    if (!config.FIREBASE_API_KEY.startsWith('AIza')) {
      console.log('‚ùå Firebase API key should start with "AIza"');
      return false;
    }

    if (!config.FIREBASE_AUTH_DOMAIN.includes('.firebaseapp.com')) {
      console.log('‚ùå Auth domain should end with .firebaseapp.com');
      return false;
    }

    if (!config.FIREBASE_APP_ID.includes(':')) {
      console.log('‚ùå App ID should contain a colon (:)');
      return false;
    }

    return true;
  }

  /**
   * Generate new environment file content
   */
  private generateEnvContent(config: FirebaseConfig): string {
    const envLines = [
      '# ELIRA Frontend Environment Variables',
      '# WARNING: Never commit this file to version control', 
      '# Generated by rotate-keys.ts on ' + new Date().toISOString(),
      '',
      '# Firebase Configuration (Client SDK)',
      `NEXT_PUBLIC_FIREBASE_API_KEY="${config.FIREBASE_API_KEY}"`,
      `NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="${config.FIREBASE_AUTH_DOMAIN}"`,
      `NEXT_PUBLIC_FIREBASE_PROJECT_ID="${config.FIREBASE_PROJECT_ID}"`,
      `NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="${config.FIREBASE_STORAGE_BUCKET}"`,
      `NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="${config.FIREBASE_MESSAGING_SENDER_ID}"`,
      `NEXT_PUBLIC_FIREBASE_APP_ID="${config.FIREBASE_APP_ID}"`
    ];

    if (config.FIREBASE_MEASUREMENT_ID) {
      envLines.push(`NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID="${config.FIREBASE_MEASUREMENT_ID}"`);
    }

    envLines.push(
      '',
      '# Additional Configuration',
      'NODE_ENV=development',
      'NEXT_PUBLIC_APP_URL="http://localhost:3000"',
      '',
      '# Firebase Admin SDK (Server-side only)', 
      '# This should point to a secure location outside the public repository',
      'GOOGLE_APPLICATION_CREDENTIALS="../secure/elira-67ab7-firebase-adminsdk.json"',
      '',
      '# Security Settings',
      'NEXT_PUBLIC_ENABLE_ANALYTICS=false',
      'NEXT_PUBLIC_DEBUG_MODE=true',
      '',
      '# Stripe Configuration (add your keys)',
      'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_test_your_stripe_publishable_key_here"',
      '',
      '# Mux Configuration (add your keys)', 
      'NEXT_PUBLIC_MUX_ENV_KEY="your-mux-env-key-here"'
    );

    return envLines.join('\n');
  }

  /**
   * Interactive configuration collection
   */
  private async collectNewConfiguration(): Promise<FirebaseConfig> {
    console.log('\nüìã Please provide new Firebase configuration values:');
    console.log('   (Get these from: Firebase Console > Project Settings > General)');
    console.log('');

    const config: FirebaseConfig = {
      FIREBASE_API_KEY: await askQuestion('Firebase API Key (starts with AIza): '),
      FIREBASE_AUTH_DOMAIN: await askQuestion('Auth Domain (e.g., project.firebaseapp.com): '),
      FIREBASE_PROJECT_ID: await askQuestion('Project ID: '),
      FIREBASE_STORAGE_BUCKET: await askQuestion('Storage Bucket (e.g., project.appspot.com): '),
      FIREBASE_MESSAGING_SENDER_ID: await askQuestion('Messaging Sender ID: '),
      FIREBASE_APP_ID: await askQuestion('App ID (e.g., 1:123:web:abc): ')
    };

    const measurementId = await askQuestion('Measurement ID (optional, press Enter to skip): ');
    if (measurementId.trim()) {
      config.FIREBASE_MEASUREMENT_ID = measurementId.trim();
    }

    return config;
  }

  /**
   * Write new configuration to files
   */
  private writeConfiguration(config: FirebaseConfig): void {
    // Write .env.local
    const envContent = this.generateEnvContent(config);
    fs.writeFileSync(this.envLocalPath, envContent);
    console.log(`‚úÖ Updated ${this.envLocalPath}`);

    // Update functions/.env if it exists
    if (fs.existsSync(this.functionsEnvPath)) {
      let functionsEnvContent = fs.readFileSync(this.functionsEnvPath, 'utf8');
      
      // Update FIREBASE_PROJECT_ID in functions env
      functionsEnvContent = functionsEnvContent.replace(
        /FIREBASE_PROJECT_ID=".+"/,
        `FIREBASE_PROJECT_ID="${config.FIREBASE_PROJECT_ID}"`
      );
      
      fs.writeFileSync(this.functionsEnvPath, functionsEnvContent);
      console.log(`‚úÖ Updated ${this.functionsEnvPath}`);
    }
  }

  /**
   * Run security verification
   */
  private runSecurityVerification(): void {
    try {
      const { execSync } = require('child_process');
      console.log('\nüîç Running security verification...');
      execSync('node scripts/security-verification.js', { stdio: 'inherit' });
    } catch (error) {
      console.log('‚ö†Ô∏è  Security verification script not found or failed');
      console.log('   Run: node scripts/security-verification.js manually');
    }
  }

  /**
   * Main rotation process
   */
  public async rotateKeys(): Promise<void> {
    try {
      console.log('üîÑ Starting Firebase key rotation process...\n');

      // Step 1: Read current configuration
      this.currentConfig = this.readCurrentConfig();
      if (this.currentConfig) {
        console.log('üìñ Current configuration found');
        console.log('   Project ID:', this.currentConfig.FIREBASE_PROJECT_ID);
        console.log('   Auth Domain:', this.currentConfig.FIREBASE_AUTH_DOMAIN);
      } else {
        console.log('üìù No current configuration found, creating new setup');
      }

      // Step 2: Create backup
      console.log('\nüìÅ Creating secure backup...');
      this.createSecureBackup();

      // Step 3: Collect new configuration
      const newConfig = await collectNewConfiguration();

      // Step 4: Validate configuration
      console.log('\nüîç Validating new configuration...');
      if (!this.validateConfig(newConfig)) {
        console.log('‚ùå Configuration validation failed. Please check your values.');
        rl.close();
        return;
      }
      console.log('‚úÖ Configuration validation passed');

      // Step 5: Confirm before writing
      const confirm = await askQuestion('\n‚ùì Write new configuration? (y/N): ');
      if (confirm.toLowerCase() !== 'y') {
        console.log('‚ùå Operation cancelled');
        rl.close();
        return;
      }

      // Step 6: Write new configuration
      console.log('\nüìù Writing new configuration...');
      this.writeConfiguration(newConfig);

      // Step 7: Run security verification
      this.runSecurityVerification();

      console.log('\nüéâ Firebase key rotation completed successfully!');
      console.log('\nüìã Next steps:');
      console.log('   1. Test your application with the new keys');
      console.log('   2. Update any CI/CD environments');
      console.log('   3. Rotate service account keys if needed');
      console.log('   4. Deploy to Firebase: firebase deploy');

    } catch (error) {
      console.error('‚ùå Error during key rotation:', error);
      console.log('\nüîÑ Backups are available in:', this.secureBackupsPath);
    } finally {
      rl.close();
    }
  }
}

// Export for testing
export { FirebaseKeyRotator };

// Run if called directly
if (require.main === module) {
  const rotator = new FirebaseKeyRotator();
  rotator.rotateKeys();
}